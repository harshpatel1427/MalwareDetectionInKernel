Homework 2 - Operating Systems ( CSE 506 )
Harshkumar Patel ( SBU ID: 110371010 )

*Adding anti-malware support for detecting and preventing virus patterns in linux files.*


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


*****List of newly created files for this assignmenst:*****


new_ioctl_number.h : This file contains new ioctl numbers for ioctl that are added for adding, removing and listing virus patterns from user side. It also specifies the structure to pass these arguments to
		     the Kernel.

link_list_struct.h:  This file contains structure for the link list that is created for the purpose of storing virus patterns inside memory. It also specifies various methods related to link list operations.

link_list_op.c:      This file contains implementation for all link list operations including adding, removing, listing patterns along with methods for flusing in memory patterns to file and freeing up all 
                     link list structures on umount. It also contains methods that check for occurence of virus patterns in buffer that is passed after read/write.

amfsctl.c: 	     This file contains user code that handles options provided by user and responsible for calling appropriate ioctl for various operations.


*****List of files that are modified for this assignments:*****

amfs.h:		     Added couple of entries in amfs_sb_info to get extra information required for amfs.

file.c:		     Added few methods that are used for checking whether file is already bad or not and then it will be un/marked accordingly. It also contains methods called "filldir" that is called at the
		     time of listing files of directory.

main.c:		     Added code that handles various mount option validation and responsible for creating in memory patterns from the file given at the time of mounting.

super.c:	     Added code that free up memory allocated for extra added things to amfs_sb_info. Memory will be freed upon unmounting.


*Note: All code of wrapfs is copied into folder named "amfs" and then changes as mentioned above are done in that.



******************************************************************************** Fuctionality and Flow of executation *******************************************************************************************



User will provide his pattern database file at the time of mounting, patterns delimated by new line are fetched from the files and stored in a array of link list. Patterns are stored based on the ascii value
of its first character. If all the patterns are successfully added then it will allow mounting. If file doesn't exists or user don't have permission for that then mounting won't be allowed. Once the amfs is
mounted, normal user can add, delete or even list all the patterns by executing "amfsctl" executable. Addition of duplicate patterns are not allowed at the time of mounting and from the user side also.

Blocking access for files that are malacious: Whenever amfs_read or amfs_write is called, it will check for patterns inside read/write buf and if file is bad then its extended attribute will be set. One
optimization implemented here is that we can skip some of the scanning for particular file as follow: We will maintain a kind of version number (changes only when a pattern is removed from database) for all
the files that keeps the count of number of patterns removed from the pattern database. If file's version number doesn't match with that of current count then it means that some of pattern is removed from the database and file is needed another scan. Scenario in which we can skip a scan is when we find both the counts same and file is already bad then there is no need to scan again as no patterns are removed from
the databse after the file is scanned.

If file is no longer bad then we'll update its version number to current remove count and remove its extended attribute. As extended attributes are stored on disk, there is no need to store it for good file aswe are maintaining version number also. Pattern databse file is very confidential file so we'll change its "chattr" so that no one will able to open it (not even root). This attribute is only unset at the timeof mounting so that patterns can be read from it and at the time of umounting so that in memory pattern can be flushed to the file. One cannot see malacious files in "ls" command. Also one cannot do any
operations such as "rm", "mv", "cat" etc. for the pattern database file.

If the file is marked as a bad, one cannot print its contents through "cat" command. If one opens it through "vi" like editor he can see the content of it but will not be able to modify it. For any good file, if data written to it are malacious then it will be marked as bad as soon as pattern is detected while writing. In this case, write operation will be allowed though as file can change its state in future.

Validations for passed arguments are perfomed mainly at two places. At the time of mounting, mount options are checked and at the time when user run "amfsctl" for adding, listing or deleting patterns. Both
validations are explained in detail in "Validation" section.



************************************************************* Followed policy for different implemented functionalities***************************************************************************************



State of a file: 		File can change its state from malacious to non-malacious and vice-versa depending on patterns added/removed. Here it is NOT assumed that once a file is bad always remain bad.

Data stucture to store patterns: Here, array of link list is used to store in memory patterns. Simple reaason behind this is to make sure that at the time of pattern search (which will occur very frequently)
				operation will be performed very fast. Here patterns are stored at the array index based on the ascii value of its first character. As patterns can start with number, characters 				 and even special characters, array of length 96 is created for each character within ascii value range 32 to 127. Patterns can even start with 'space'. This will allow us fast
				lookup at the time of searching as well as it will also be useful when searching for duplicate patterns while adding. For pattern existence while removing it, it can be easily
				detected if pattern exists or not compare to single linear link list.

Flusing patterns to file:	Safest way to keep patterns are to ensure that every time when new pattern is added or deleted we have to write that to the file. But this can make the entire thing slow due to
				frequent I/O operations. Here, patterns are flushed to the file only at the time of unmounting and main purpose behind this is to ensure that operation can be fast as much as
				possible. But this includes the risk of loosing patterns if system crashes or some failure happens. So it is a kind of trade-off but as pattern file is very important thing it
				is assumed that user must have more than one copy of it stored securely somewhere else. By making this assumption we can make system more faster and avoid unwanted frequent I/O.				 At the time of flushing also it is first written into the temp file and if everything goes well then and only then it will renamed to original file thus ensuring safety as much
				as possible.



**************************************************************************** Important implemented features*****************************************************************************************************



1. Not allowing addition of duplicated patterns. As patterns are kept in memory allowing addition of same pattern more than once will take up more memory and have no purpose to serve.

2. Similarly, if patterns are duplicated inside the file at the time of mounting then also duplicated patterns will be skiped and only one time it will be stored. Serving the similar purpose as above.

3. Avoiding frequent I/O by not flusing patterns to file. Trade-off is explained in policy section above.

4. Preventing pattern database file from being accessed/modified/deleted by setting "chattr" of the file. Even after unmount one cannot modify it and new patterns will be added through ioctls only.

5. Blocking bad file at the time of reading it. If file is good and made bad while writing then write operation is allowed as file can change its state in future.

6. Avoiding repeated scan of a bad file: For a bad file with same version number as current remove count there is no meaning of scanning it again as no pattern is removed from database since file was scanned.
   This is a kind of optimization performed based on the extended attributes set for file.

7. Preventing bad files from listing through "ls" command. User has to remember file name in order to delete it from the file system.

8. choosing an appropriate data structure to store patterns in memory. As explained in above section, used array of link list for faster lookup and prevention of duplicated patterns.

9. Using a temp file while flushing so that data can be kept safe from loosing as much as possible. If everything is successful then it will be renamed to original file.

10. Allowing patterns starting with any characters, special characters or numbers. Patterns can span across more than one word too.



***************************************************************************** Limitation *********************************************************************************************************************



1. As explained earlier, flushing file only once will be risky as one can loose all the patterns if system failure occurs. But with minor alternatives such as maintainig a secure copy of patterns can lessen
   the impact of the lost caused by system failure.

2. Patterns can be no longer than 256 characters. If it is so then that pattern will be discarded at the time of mouting and while normal user is adding it then it will throw invalid argument error to him.

3. As pattern database file is marked with "chattr", after first mounting, patterns can be added only through ioctl.

4. Pattern file should exists inside the mounted directory (i.e. inside directory listed as dev_name in mount). If file doesn't exists or appropriate permissions are not there for user mounting it then
   mounting will not be allowed.

5. There is no limitation on the size of pattern file however pattern spanning across two consecutive pages in memory while reading are treated as two different patterns instead of one.



*********************************************************************** How this code is tested **************************************************************************************************************



First mounted ext3 (/dev/sda1) on /mnt/lower (created first) directory. Then run "make" inside 'hw2-hcpatel' directory (copy kernel.config file to .config file first) which will generate object files and
modules. Then did "insmod amfs.ko" inside "amfs" subdirectory of "hw2-hcpatel/fs/". After that mounted /mnt/lower on /mnt/amfs (created /mnt/amfs first) by following command.

mount -t amfs -o pattdb=pattern.db /mnt/lower /mnt/amfs

Here, "pattern.db" should exists somewhere inside /mnt/lower otherwise mounting won't be allowed. Then after that to list the patterns or to add or delete them run "amfsctl" executable inside "/usr/src/hw2-hcpatel/fs/amfs"  as follow.

To Compile: gcc -Wall -Werror amfsctl.c -o amfsctl

To Run: ./amfsctl -l /mnt/amfs (or) ./amfsctl -a "pattern" /mnt/amfs (or) ./amfsctl -r "pattern" /mnt/amfs

After that checked bad file's accessbility and lising directory contents and other things inside /mnt/amfs directory. After unmounting pattern database with updated pattern list (if any) can be found at the
same place where it was before inside /mnt/lower.

To unmount use:

umount /mnt/amfs

rmmod amfs.ko (removing module)



**************************************************************************** Validating Arguments *************************************************************************************************************


**** User side operations ****

Validated arguments passed by user while running "amfsctl" executable. For listing user can't pass any argument apart from mount point. For addition, pattern length should be less than 256 characters. No
duplication of pattern are allowed. For deletion the passed argument should exist in pattern list else error will be thrown. Errors are interpreted using function "perror". Patterns to be added or deleted
can't be empty. User can pass only one of these three parameters else error will be thrown along with command usage message. Mount point should be either "/mnt/amfs" (or) "/mnt/amfs/" otherwise error will be
given.

**** Mount option validation ****

At the time of mounting, inside option part, one has to mention "pattdb=" to indicate pattern database file otherwise error will be thrown. After "pattdb=" one can mention path to the pattern database file.
This path can include any number of subdirectory inside mounted device (i.e. /mnt/lower ). But the file should reside inside /mnt/lower and user has to give path after "/mnt/lower" in option followed by
"pattdb=". For an example if /mnt/lower is mounted on /mnt/amfs and pattern file resides in /mnt/lower/mytest then following is the correct way to give mount option.

mount -t -o pattdb=/mytest/pattern.db /mnt/lower /mnt/amfs

Here, one thing to note is that "/" is optional after "lower" and before "mytest". It is specifically handled through the code before opening file with proper path at the time of mounting.



******************************************************************************* References ********************************************************************************************************************

1. ecryptfs source code : http://lxr.free-electrons.com/source/fs/ecryptfs/
2. For hiding file in 'ls' : http://www.codeproject.com/Articles/444995/Driver-to-hide-files-in-Linux-OS#
3. Discussed about data structure to use and how to use 'chattr' with Nirmit Desai and Shubhada Patil
4. Read Research Papers mentioned in hw2 and wrapfs code: http://git.fsl.cs.sunysb.edu/
5. Regarding stackable f/s: http://wrapfs.filesystems.org/docs/linux-stacking/index.html
6. Using strsep: http://apiexamples.com/c/string/strsep.html
