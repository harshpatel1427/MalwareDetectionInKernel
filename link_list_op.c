/* This file contains methods for adding pattern
* to the link list, removing it from link list and
* for displaying all the patterns of link list
* which is stored in memory.It also contains methods
* for checking file attribute so that it can be marked
* as good or bad. It also defines method for storing
* in memory patterns to file, changing its attributes etc.
*/

#include <linux/string.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/fs.h>
#include <linux/namei.h>
#include "link_list_struct.h"

node_t *pattern_array_head[96];
int remove_count;

/*
* check_file_contents
* @buf: buf in which virus needs to be scanned
*
* This function checks whether buf contains any
* malware pattern or not. It looks for pattern
* inside buffer and compare them with patterns
* that are there in the memory.
*
* Returns zero if file is malware free else
* returns EPERM.
*/
int check_file_contents(char *buf)
{
	node_t *head;
	int i, error = 0;

	for (i = 0; i < 96; i++) {
		head = pattern_array_head[i];
		while (head != NULL) {
			if (strstr(buf, head->pattern) != NULL) {
				pr_info("Match found for %s\n", head->pattern);
				error = -EPERM;
				goto out;
			}
			head = head->next;
		}
	}
out:
	return error;
}

/*
* change_chattr
* @file: file in question
* @selection: indicates whether to set or unset attribute
*
* This function un/set IMMUTABLE flag for file. This is used
* so that no one can modify, rename or delete pattern databse
* file. Unset parameter is called when we needed to read patterns
* from it while mounting or at the time of the unmount when we
* need to dump in memory patterns to file.
*
* Returns zero on successful setting of flags.
*/
int change_chattr(struct file *file, int selection)
{
	int ret, flags = 0;
	mm_segment_t oldfs;

	oldfs = get_fs();
	set_fs(KERNEL_DS);

	ret = file->f_op->unlocked_ioctl(file, FS_IOC_GETFLAGS,
						(unsigned long)&flags);

	set_fs(oldfs);

	if (selection)
		flags = flags | FS_IMMUTABLE_FL;
	else
		flags = flags & ~FS_IMMUTABLE_FL;

	if (ret == 0) {
		oldfs = get_fs();
		set_fs(KERNEL_DS);

		ret = file->f_op->unlocked_ioctl(file, FS_IOC_SETFLAGS,
							(unsigned long)&flags);

		set_fs(oldfs);
	}
	return ret;
}

/*
* dump_to_file
* @new_fp: new file in question
* @old_fp: old file in question
*
* This function is called on unmount when we need to
* flush in memory patterns to the file. Purpose for using
* two file pointers are to ensure that patterns don't get
* lost while writing. So first temp file will be created
* and after that it'll be renamed.
*
* Returns zero on success else EINVAL or ENOTEMPTY if write
* or rename is unsuccessful.
*/
int dump_to_file(struct file *new_fp, struct file *old_fp)
{
	int error = 0, bytes_written = 0, i;
	struct dentry *trap, *lower_old_dir_dentry, *lower_new_dir_dentry;
	node_t *head;
	mm_segment_t oldfs;

	oldfs = get_fs();
	set_fs(KERNEL_DS);

	new_fp->f_pos = 0;
	for (i = 0; i < 96; i++) {
		head = pattern_array_head[i];
		while (head != NULL) {
			bytes_written = vfs_write(new_fp, head->pattern,
								strlen(head->pattern), &new_fp->f_pos);
			if (bytes_written != strlen(head->pattern)) {
				pr_info("Unable to write to file\n");
				error = bytes_written;
				goto close;
			}

			bytes_written = vfs_write(new_fp, "\n", 1, &new_fp->f_pos);
			if (bytes_written != 1) {
				pr_info("Unable to write to file\n");
				error = bytes_written;
				goto close;
			}
			head = head->next;
		}
	}

	lower_old_dir_dentry = dget_parent(new_fp->f_path.dentry);
	lower_new_dir_dentry = dget_parent(old_fp->f_path.dentry);

	trap = lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
	if (trap == new_fp->f_path.dentry) {
		error = -EINVAL;
		goto free_lock;
	}

	if (trap == old_fp->f_path.dentry) {
		error = -ENOTEMPTY;
		goto free_lock;
	}

	/* Setting remove count xattr for pattern database file so that it can be used when remounted */

	new_fp->f_inode->i_op->setxattr(new_fp->f_path.dentry, "user.rmcount",
						(void *)&remove_count, sizeof(int), 0);

	error = vfs_rename(d_inode(lower_old_dir_dentry), new_fp->f_path.dentry,
					d_inode(lower_new_dir_dentry), old_fp->f_path.dentry, NULL, 0);
	if (error)
		pr_info("Unexpected Error! Unable to Rename Temp File\n");

free_lock:
	unlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
close:
	set_fs(oldfs);
	return error;
}

/*
* remove_patterns
*
* This function will free all the memory allocated
* for the array of link list that was used to storing
* in memory patterns.
*
* Returns zero on success.
*/
int remove_patterns(void)
{
	node_t *next, *cur;
	int i, error = 0;

	for (i = 0; i < 96; i++) {
		cur = pattern_array_head[i];
		while (cur != NULL) {
			next = cur->next;
			kfree(cur->pattern);
			kfree(cur);
			cur = next;
		}
	}
	return error;
}

/*
* add_pattern
* @pattern: pattern to be added to the link list
*
* This function is called when the new pattern is added
* to the existing pattern list.
*
* Returns zero on successful adding or EINVAL if
* pattern already exists in the pattern list.
*/
int add_pattern(char *pattern)
{
	int char_val = (int)pattern[0];
	int error = 0;
	node_t *node = NULL, *cur = NULL, *prev = NULL;

	node = kmalloc(sizeof(node_t), GFP_KERNEL);
	node->pattern = NULL;
	node->pattern = kmalloc(sizeof(char) * strlen(pattern), GFP_KERNEL);

	cur = pattern_array_head[char_val - 32];
	prev = cur;
	if (cur == NULL) {
		strcpy(node->pattern, pattern);
		node->next = NULL;
		pattern_array_head[char_val - 32] = node;
	} else {
		while (cur != NULL) {
			if (strcmp(cur->pattern, pattern) == 0) {
				pr_info("Match found while adding!\n");
				error = -EINVAL;
				goto out;
			}
			prev = cur;
			cur = cur->next;
		}
		strcpy(node->pattern, pattern);
		node->next = NULL;
		prev->next = node;
	}
out:
	if (error != 0) {
		kfree(node->pattern);
		kfree(node);
	}
	return error;
}

/*
* delete_pattern
* @pattern_to_delete: pattern to be deleted from the link list
*
* This function is called when the pattern is needed to be
* deleted from the existing pattern list.
*
* Returns zero on successful adding or EINVAL if
* pattern doesn't exists in the pattern list.
*/
int delete_pattern(char *pattern_to_delete)
{
	node_t *cur, *prev_node;
	int error = 0;
	int char_val = (int)pattern_to_delete[0];

	cur = pattern_array_head[char_val - 32];
	prev_node = cur;
	if (cur == NULL) {
		/* No pattern to delete */
		error = -EINVAL;
		goto out;
	}
	if (strcmp(cur->pattern, pattern_to_delete) == 0) {
		if (cur->next == NULL) {
			kfree(cur);
			pattern_array_head[char_val - 32] = NULL;
			goto out;
		} else {
			pattern_array_head[char_val - 32] = cur->next;
			kfree(cur);
			goto out;
		}
	} else {
		cur = cur->next;
		while (cur != NULL) {
			if (strcmp(cur->pattern, pattern_to_delete) == 0) {
				prev_node->next = cur->next;
				kfree(cur);
				goto out;
			} else {
				prev_node = cur;
				cur = cur->next;
			}
		}
		/* No patterns to delete */
		error = -EINVAL;
		goto out;
	}

out:
	remove_count = remove_count + 1;

	return error;
}

/*
* get_length
*
* This function is called when we need to know length
* of the pattern so that user can send appropriate length
* buffer to list all the patterns.
*
* Returns total length of the all the patterns along
* with new line to print line by line patterns on user side.
*/
int get_length(void)
{
	int i, length = 0;
	node_t *head;

	for (i = 0; i < 96; i++) {
		head = pattern_array_head[i];
		while (head != NULL) {
			length = length + 1 + strlen(head->pattern);
			head = head->next;
		}
	}
	return length;
}

/*
* list_pattern
* @temp: User buffer to which all the patterns will be copied
*
* This functions get all the patterns from the link list and
* copies them to the user's provided buffer.
*/
void list_pattern(char *temp)
{
	int i, count = 0;
	node_t *head = NULL;

	for (i = 0; i < 96; i++) {
		head = pattern_array_head[i];
		while (head != NULL) {
			strcpy(temp + count, head->pattern);
			count = count + strlen(head->pattern);
			strcpy(temp + count, "\n");
			count = count + 1;
			head = head->next;
		}
	}
	temp[count] = 0;
}
